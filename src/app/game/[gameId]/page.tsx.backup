'use client';

import { useRouter, useParams } from 'next/navigation';
import { useEffect, useState } from 'react';
import { useAuth } from '@/hooks/useAuth';
import { getGame, subscribeToGame, updateGame, placeBomb, defuseBomb, activateBombs, setPlayerChoice, handleGameEnd, subscribeToChat, sendChatMessage } from '@/services/gameService';
import { Game, Player, Position, CellState, Bomb, LobbyMessage } from '@/types/game';
import { Grid } from '@/components/game/Grid';
import { GameChat } from '@/components/game/GameChat';
import { GameInterface } from '@/components/game/GameInterface';
import { saveGameToHistory, GameHistoryEntry } from '@/utils/gameHistory';
import { updateUserStatsAfterGame } from '@/services/userService';
import { setInGame, setOnline } from '@/services/presenceService';

// Hook pour calculer la taille des cellules selon la taille d'√©cran
function useCellSize() {
  const [cellSize, setCellSize] = useState(32);
  const [padding, setPadding] = useState(16);

  useEffect(() => {
    const updateSize = () => {
      if (window.innerWidth < 640) {
        setCellSize(20);
        setPadding(8);
      } else if (window.innerWidth < 768) {
        setCellSize(24);
        setPadding(16);
      } else {
        setCellSize(32);
        setPadding(16);
      }
    };

    updateSize();
    window.addEventListener('resize', updateSize);
    return () => window.removeEventListener('resize', updateSize);
  }, []);

  return { cellSize, padding };
}

export default function GamePage() {
  const router = useRouter();
  const params = useParams();
  const gameId = params.gameId as string;
  const { user } = useAuth();
  
  const [game, setGame] = useState<Game | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [actionMode, setActionMode] = useState<'shot' | 'bomb'>('shot'); // Mode d'action : tir ou bombe
  const [playerChoice, setPlayerChoiceState] = useState<'lobby' | 'menu' | null>(null); // Choix du joueur actuel
  const [selectedTarget, setSelectedTarget] = useState<string | null>(null); // Adversaire s√©lectionn√© pour attaquer
  const [hasShotThisTurn, setHasShotThisTurn] = useState(false); // V√©rifier si on a d√©j√† tir√© ce tour
  const [timeRemaining, setTimeRemaining] = useState<number | null>(null); // Temps restant en secondes
  const [chatMessages, setChatMessages] = useState<LobbyMessage[]>([]); // Messages du chat
  const { cellSize, padding } = useCellSize();

  // Charger la partie et √©couter les changements
  useEffect(() => {
    if (!gameId || !user) {
      router.push('/dashboard');
      return;
    }

    const loadGame = async () => {
      try {
        const loadedGame = await getGame(gameId);
        if (loadedGame) {
          setGame(loadedGame);
          // V√©rifier que l'utilisateur est dans la partie
          const player = loadedGame.players.find(p => p.id === user.uid);
          if (!player) {
            router.push('/dashboard');
            return;
          }
          
          // Si la phase n'est pas 'playing', rediriger
          if (loadedGame.phase !== 'playing') {
            if (loadedGame.phase === 'placement') {
              router.push(`/placement?gameId=${gameId}`);
            } else if (loadedGame.phase === 'lobby') {
              router.push(`/lobby?gameId=${gameId}`);
            } else {
              router.push('/dashboard');
            }
            return;
          }
        } else {
          router.push('/dashboard');
        }
      } catch (error) {
        console.error('Erreur lors du chargement de la partie:', error);
        router.push('/dashboard');
      } finally {
        setLoading(false);
      }
    };

    loadGame();
    
    // √âcouter les changements de la partie en temps r√©el
    const unsubscribe = subscribeToGame(gameId, async (updatedGame) => {
      setGame(updatedGame);
      
      // Si le jeu a √©t√© supprim√©, rediriger vers le dashboard
      if (!updatedGame) {
        router.push('/dashboard');
        return;
      }

      // Activer les bombes qui doivent s'activer
      if (updatedGame.phase === 'playing') {
        await activateBombs(gameId);
        
        // V√©rifier si le joueur actuel doit √™tre saut√© (skipNextTurns > 0)
        const currentPlayer = updatedGame.players[updatedGame.currentPlayerIndex];
        if (currentPlayer && currentPlayer.skipNextTurns && currentPlayer.skipNextTurns > 0) {
          // D√©cr√©menter skipNextTurns et passer au joueur suivant
          const updatedPlayers = updatedGame.players.map((p, index) => {
            if (index === updatedGame.currentPlayerIndex) {
              return {
                ...p,
                skipNextTurns: (p.skipNextTurns || 0) - 1,
              };
            }
            return p;
          });
          
          // Trouver le prochain joueur qui peut jouer
          let nextPlayerIndex = (updatedGame.currentPlayerIndex + 1) % updatedGame.players.length;
          let attempts = 0;
          const maxAttempts = updatedGame.players.length * 2;
          
          while (attempts < maxAttempts) {
            const nextPlayer = updatedPlayers[nextPlayerIndex];
            
            // Si le joueur est vivant et n'a pas de tours √† sauter, c'est le bon
            if (nextPlayer.isAlive && (!nextPlayer.skipNextTurns || nextPlayer.skipNextTurns === 0)) {
              break;
            }
            
            // Si le joueur a des tours √† sauter, d√©cr√©menter le compteur
            if (nextPlayer.skipNextTurns && nextPlayer.skipNextTurns > 0) {
              const playerIndex = updatedPlayers.findIndex(p => p.id === nextPlayer.id);
              if (playerIndex !== -1) {
                updatedPlayers[playerIndex] = {
                  ...nextPlayer,
                  skipNextTurns: nextPlayer.skipNextTurns - 1,
                };
              }
            }
            
            // Passer au joueur suivant
            nextPlayerIndex = (nextPlayerIndex + 1) % updatedPlayers.length;
            attempts++;
          }
          
          await updateGame(gameId, {
            players: updatedPlayers,
            currentPlayerIndex: nextPlayerIndex,
            currentTurn: (updatedGame.currentTurn || 0) + 1,
            turnStartTime: Date.now(),
          });
          
          await activateBombs(gameId);
        }
      }
      
        // Si la partie est termin√©e, sauvegarder dans l'historique et mettre √† jour les stats
        if (updatedGame.phase === 'finished' && updatedGame.winnerId && user) {
          const currentPlayer = updatedGame.players.find(p => p.id === user.uid);
          const winner = updatedGame.players.find(p => p.id === updatedGame.winnerId);
          
          if (currentPlayer) {
            const historyEntry: GameHistoryEntry = {
              gameId: updatedGame.id,
              gameCode: updatedGame.code,
              players: updatedGame.players.map(p => ({
                id: p.id,
                name: p.name,
                color: p.color,
              })),
              winnerId: updatedGame.winnerId,
              winnerName: winner?.name,
              isWinner: currentPlayer.id === updatedGame.winnerId,
              finishedAt: Date.now(),
              phase: 'finished',
            };
            
            saveGameToHistory(historyEntry);
            
            // Calculer les statistiques du joueur pour cette partie
            // Compter les tirs effectu√©s par le joueur sur les adversaires
            // (les cases 'hit' ou 'miss' sur les grilles des adversaires)
            let shots = 0;
            let hits = 0;
            let shipsSunk = 0;
            
            updatedGame.players
              .filter(p => p.id !== currentPlayer.id)
              .forEach(opponent => {
                // Compter les tirs sur cette grille adverse
                const opponentShots = opponent.board.cells.flat().filter(
                  cell => cell === 'hit' || cell === 'miss'
                ).length;
                const opponentHits = opponent.board.cells.flat().filter(
                  cell => cell === 'hit'
                ).length;
                
                // On suppose que tous les tirs sur cette grille sont du joueur actuel
                // (en r√©alit√©, en mode 1v1v1, plusieurs joueurs peuvent tirer sur le m√™me adversaire)
                // Pour simplifier, on divise par le nombre de joueurs qui ont pu tirer
                const playersWhoCouldShoot = updatedGame.players.filter(p => p.id !== opponent.id).length;
                shots += Math.round(opponentShots / playersWhoCouldShoot);
                hits += Math.round(opponentHits / playersWhoCouldShoot);
                
                // Compter les navires coul√©s de cet adversaire
                shipsSunk += opponent.board.ships.filter(ship => ship.sunk).length;
              });
            
            const bombsPlaced = currentPlayer.bombsPlaced.length;
            const bombsDefused = updatedGame.players
              .filter(p => p.id !== currentPlayer.id)
              .reduce((total, opponent) => {
                return total + opponent.bombsPlaced.filter(bomb => 
                  bomb.targetPlayerId === currentPlayer.id && bomb.defused
                ).length;
              }, 0);
            const isAbandoned = !currentPlayer.isAlive && currentPlayer.id !== updatedGame.winnerId;
            
            // Mettre √† jour les statistiques
            await updateUserStatsAfterGame(user.uid, {
              isWinner: currentPlayer.id === updatedGame.winnerId,
              isAbandoned,
              shots,
              hits,
              shipsSunk,
              bombsPlaced,
              bombsDefused,
            });
          }
        }
        
        // Si la partie est termin√©e, v√©rifier si le joueur a d√©j√† fait un choix
        if (updatedGame.phase === 'finished') {
          const choices = updatedGame.playerChoices || {};
          if (user && choices[user.uid]) {
            setPlayerChoiceState(choices[user.uid]);
          }
        }
        
        // Si le jeu est retourn√© au lobby, rediriger tous les joueurs
        if (updatedGame.phase === 'lobby') {
          // V√©rifier que le joueur actuel est toujours dans la partie
          const playerStillInGame = updatedGame.players.some(p => p.id === user?.uid);
          if (playerStillInGame) {
            router.push(`/lobby?gameId=${gameId}`);
          } else {
            // Le joueur n'est plus dans la partie, rediriger vers le dashboard
            router.push('/dashboard');
          }
        }
    });

    return () => {
      unsubscribe();
    };
  }, [gameId, user, router]);

  // Mettre √† jour la pr√©sence quand on entre dans une partie
  useEffect(() => {
    if (!user || !gameId) return;

    setInGame(user.uid, gameId);

    return () => {
      // Quand on quitte la page, remettre en ligne
      setOnline(user.uid);
    };
  }, [user, gameId]);

  // √âcouter le chat
  useEffect(() => {
    if (!gameId) return;

    const unsubscribe = subscribeToChat(gameId, setChatMessages);
    return unsubscribe;
  }, [gameId]);

  // Envoyer un message dans le chat
  const handleSendChatMessage = async (message: string) => {
    if (!gameId || !user || !currentPlayer) return;

    try {
      await sendChatMessage(
        gameId, 
        user.uid, 
        currentPlayer.name, 
        message,
        'in-game',
        game?.phase
      );
    } catch (error) {
      console.error('Erreur lors de l\'envoi du message:', error);
    }
  };

  // Obtenir le joueur actuel
  const currentPlayer = game?.players.find(p => p.id === user?.uid);
  const currentPlayerTurn = game?.players[game.currentPlayerIndex];
  // Le joueur peut jouer seulement s'il est le joueur actuel ET qu'il n'a pas de tours √† sauter
  const isCurrentTurn = game && 
    game.players[game.currentPlayerIndex]?.id === user?.uid &&
    (!currentPlayerTurn?.skipNextTurns || currentPlayerTurn.skipNextTurns === 0);
  
  // Obtenir les adversaires (joueurs vivants sauf soi)
  const opponents = game?.players.filter(p => p.id !== user?.uid && p.isAlive) || [];
  
  // R√©initialiser le tir et la s√©lection quand le tour change
  useEffect(() => {
    if (game && isCurrentTurn) {
      const currentPlayer = game.players.find(p => p.id === user?.uid);
      // R√©initialiser hasShotThisTurn seulement si on n'a pas de tours bonus
      // (les tours bonus sont g√©r√©s dans handleCellClick)
      if (!currentPlayer?.bonusTurns || currentPlayer.bonusTurns === 0) {
        setHasShotThisTurn(false);
      }
      setActionMode('shot');
      
      // Si un seul adversaire, le s√©lectionner automatiquement
      const aliveOpponents = game.players.filter(p => p.id !== user?.uid && p.isAlive);
      if (aliveOpponents.length === 1) {
        setSelectedTarget(aliveOpponents[0].id);
      } else {
        setSelectedTarget(null);
      }
    }
  }, [game?.currentTurn, isCurrentTurn, game?.players, user?.uid]);

  // G√©rer le timer du tour
  useEffect(() => {
    if (!game || game.phase !== 'playing' || !game.settings.turnTimeLimit || game.settings.turnTimeLimit === 0) {
      setTimeRemaining(null);
      return;
    }

    // Si turnStartTime n'est pas d√©fini, l'initialiser
    if (!game.turnStartTime && isCurrentTurn) {
      updateGame(game.id, { turnStartTime: Date.now() }).catch(console.error);
      return;
    }

    const turnStartTime = game.turnStartTime || Date.now();
    const timeLimit = game.settings.turnTimeLimit * 1000; // Convertir en millisecondes

    const updateTimer = () => {
      const elapsed = Date.now() - turnStartTime;
      const remaining = Math.max(0, Math.floor((timeLimit - elapsed) / 1000));
      setTimeRemaining(remaining);

      // Si le temps est √©coul√© et que c'est le tour du joueur actuel, passer au tour suivant
      if (remaining === 0 && isCurrentTurn && !hasShotThisTurn) {
        handleTimeExpired();
      }
    };

    // Mettre √† jour imm√©diatement
    updateTimer();

    // Mettre √† jour toutes les secondes
    const interval = setInterval(updateTimer, 1000);

    return () => clearInterval(interval);
  }, [game?.turnStartTime, game?.settings.turnTimeLimit, game?.currentTurn, isCurrentTurn, hasShotThisTurn, game?.id]);

  // G√©rer l'expiration du temps
  const handleTimeExpired = async () => {
    if (!game || !isCurrentTurn || hasShotThisTurn) return;

    try {
      const currentPlayer = game.players.find(p => p.id === user?.uid);
      
      // V√©rifier si le joueur a des tours bonus
      if (currentPlayer && currentPlayer.bonusTurns && currentPlayer.bonusTurns > 0) {
        // D√©cr√©menter le compteur de tours bonus et le joueur rejoue
        const updatedPlayers = game.players.map(p => {
          if (p.id === user?.uid) {
            return {
              ...p,
              bonusTurns: (p.bonusTurns || 0) - 1,
            };
          }
          return p;
        });
        
        await updateGame(game.id, {
          players: updatedPlayers,
          turnStartTime: Date.now(), // R√©initialiser le timer pour le tour bonus
        });
      } else {
        // Passer au joueur suivant normalement
        let nextPlayerIndex = (game.currentPlayerIndex + 1) % game.players.length;
        let attempts = 0;
        const maxAttempts = game.players.length * 2;
        const updatedPlayers = game.players.map(p => ({ ...p }));
        
        while (attempts < maxAttempts) {
          const nextPlayer = updatedPlayers[nextPlayerIndex];
          
          if (nextPlayer.isAlive && (!nextPlayer.skipNextTurns || nextPlayer.skipNextTurns === 0)) {
            break;
          }
          
          // Si le joueur a des tours √† sauter, d√©cr√©menter le compteur
          if (nextPlayer.skipNextTurns && nextPlayer.skipNextTurns > 0) {
            updatedPlayers[nextPlayerIndex] = {
              ...nextPlayer,
              skipNextTurns: nextPlayer.skipNextTurns - 1,
            };
          }
          
          nextPlayerIndex = (nextPlayerIndex + 1) % updatedPlayers.length;
          attempts++;
        }

        await updateGame(game.id, {
          players: updatedPlayers,
          currentPlayerIndex: nextPlayerIndex,
          currentTurn: game.currentTurn + 1,
          turnStartTime: Date.now(),
        });
      }

      await activateBombs(game.id);
      
      // Effacer le message d'erreur apr√®s un court d√©lai
      setTimeout(() => setError(''), 2000);
    } catch (error) {
      console.error('Erreur lors du passage au tour suivant:', error);
      setError('Erreur lors du passage au tour suivant');
    }
  };

  // G√©rer un tir
  const handleCellClick = async (opponentId: string, x: number, y: number) => {
    if (!game || !user || !isCurrentTurn || !currentPlayer) return;
    if (game.phase !== 'playing') return;
    if (hasShotThisTurn) {
      setError('Vous avez d√©j√† tir√© ce tour. Attendez votre prochain tour.');
      return;
    }
    if (actionMode === 'bomb') {
      // G√©rer le placement de bombe s√©par√©ment
      return;
    }

    // V√©rifier qu'un adversaire est s√©lectionn√© (sauf si un seul adversaire)
    if (opponents.length > 1 && (!selectedTarget || selectedTarget !== opponentId)) {
      setError('S√©lectionnez d\'abord un adversaire √† attaquer');
      return;
    }
    
    // Si un seul adversaire, utiliser son ID automatiquement
    const targetId = opponents.length === 1 ? opponents[0].id : selectedTarget;
    if (!targetId || targetId !== opponentId) {
      return;
    }

    // Trouver le joueur cible
    const targetPlayer = game.players.find(p => p.id === opponentId);
    if (!targetPlayer || targetPlayer.id === user.uid || !targetPlayer.isAlive) return;

    const cellState = targetPlayer.board.cells[y]?.[x];
    // On ne peut pas tirer sur les cases d√©j√† tir√©es (hit, miss)
    // On ne peut pas tirer sur les cases r√©v√©l√©es vides (revealed_empty) car c'est un gaspillage de tir
    // MAIS on peut tirer sur les cases r√©v√©l√©es avec navire (revealed_ship) car il y a un navire √† d√©truire
    if (cellState === 'hit' || cellState === 'miss' || cellState === 'revealed' || cellState === 'revealed_empty') {
      return; // Case d√©j√† tir√©e ou r√©v√©l√©e vide
    }

    try {
      // D√©terminer le r√©sultat du tir
      const shipAtPosition = targetPlayer.board.ships.find(ship =>
        ship.positions.some(pos => pos.x === x && pos.y === y)
      );

      const newCellState: CellState = shipAtPosition ? 'hit' : 'miss';
      
      // Mettre √† jour la grille de l'adversaire
      const updatedCells = targetPlayer.board.cells.map((row, rowIndex) =>
        rowIndex === y
          ? row.map((cell, colIndex) => (colIndex === x ? newCellState : cell))
          : row
      );

      // Si un navire est touch√©, mettre √† jour ses hits
      let updatedShips = targetPlayer.board.ships;
      if (shipAtPosition) {
        updatedShips = targetPlayer.board.ships.map(ship => {
          if (ship.id === shipAtPosition.id) {
            const newHits = ship.hits + 1;
            return {
              ...ship,
              hits: newHits,
              sunk: newHits >= ship.size,
            };
          }
          return ship;
        });
      }

      // Mettre √† jour le joueur cible
      const updatedTargetPlayer: Player = {
        ...targetPlayer,
        board: {
          cells: updatedCells,
          ships: updatedShips,
        },
        isAlive: updatedShips.some(ship => !ship.sunk),
      };

      // V√©rifier si le joueur cible est mort
      const targetIsDead = !updatedTargetPlayer.isAlive;

      // Mettre √† jour la liste des joueurs
      const updatedPlayers = game.players.map(p =>
        p.id === updatedTargetPlayer.id ? updatedTargetPlayer : p
      );

      // V√©rifier s'il reste un seul joueur vivant
      const alivePlayers = updatedPlayers.filter(p => p.isAlive);

      // D√©terminer le prochain joueur
      let nextPlayerIndex = game.currentPlayerIndex;
      let hasRemainingBonusTurns = false;
      let shouldIncrementTurn = true; // Par d√©faut, on incr√©mente le tour
      
      if (!targetIsDead && alivePlayers.length > 1) {
        // V√©rifier si le joueur actuel a des tours bonus √† jouer
        const currentPlayer = updatedPlayers.find(p => p.id === user.uid);
        
        if (currentPlayer && currentPlayer.bonusTurns && currentPlayer.bonusTurns > 0) {
          // Le joueur a encore des tours bonus, il rejoue
          // D√©cr√©menter le compteur de tours bonus
          const playerIndex = updatedPlayers.findIndex(p => p.id === user.uid);
          if (playerIndex !== -1) {
            const remainingBonusTurns = currentPlayer.bonusTurns - 1;
            
            updatedPlayers[playerIndex] = {
              ...currentPlayer,
              bonusTurns: remainingBonusTurns,
            };
            // V√©rifier s'il reste encore des tours bonus apr√®s la d√©cr√©mentation
            hasRemainingBonusTurns = remainingBonusTurns > 0;
            
            // Si apr√®s la d√©cr√©mentation, il n'y a plus de tours bonus, passer au joueur suivant
            if (remainingBonusTurns === 0) {
              // Passer au joueur suivant en tenant compte des tours √† sauter
              let attempts = 0;
              const maxAttempts = updatedPlayers.length * 2;
              nextPlayerIndex = (game.currentPlayerIndex + 1) % updatedPlayers.length;
              
              while (attempts < maxAttempts) {
                const nextPlayer = updatedPlayers[nextPlayerIndex];
                
                // Ne pas revenir au joueur actuel (celui qui vient de finir ses tours bonus)
                if (nextPlayerIndex === game.currentPlayerIndex) {
                  nextPlayerIndex = (nextPlayerIndex + 1) % updatedPlayers.length;
                  attempts++;
                  continue;
                }
                
                // Si le joueur est vivant et n'a pas de tours √† sauter, c'est le bon
                if (nextPlayer.isAlive && (!nextPlayer.skipNextTurns || nextPlayer.skipNextTurns === 0)) {
                  break;
                }
                
                // Si le joueur a des tours √† sauter, d√©cr√©menter le compteur
                if (nextPlayer.skipNextTurns && nextPlayer.skipNextTurns > 0) {
                  const playerIdx = updatedPlayers.findIndex(p => p.id === nextPlayer.id);
                  if (playerIdx !== -1) {
                    updatedPlayers[playerIdx] = {
                      ...nextPlayer,
                      skipNextTurns: nextPlayer.skipNextTurns - 1,
                    };
                  }
                }
                
                // Passer au joueur suivant
                nextPlayerIndex = (nextPlayerIndex + 1) % updatedPlayers.length;
                attempts++;
              }
              
              // Incr√©menter currentTurn car on passe au joueur suivant
              shouldIncrementTurn = true;
            } else {
              // Le joueur reste le joueur actuel
              nextPlayerIndex = game.currentPlayerIndex;
              // Ne pas incr√©menter currentTurn car c'est encore le tour du m√™me joueur (tour bonus)
              shouldIncrementTurn = false;
            }
          }
        } else {
          // Passer au joueur suivant en tenant compte des tours √† sauter
          let attempts = 0;
          const maxAttempts = updatedPlayers.length * 2;
          nextPlayerIndex = (game.currentPlayerIndex + 1) % updatedPlayers.length;
          
          while (attempts < maxAttempts) {
            const nextPlayer = updatedPlayers[nextPlayerIndex];
            
            // Si le joueur est vivant et n'a pas de tours √† sauter, c'est le bon
            if (nextPlayer.isAlive && (!nextPlayer.skipNextTurns || nextPlayer.skipNextTurns === 0)) {
              break;
            }
            
            // Si le joueur a des tours √† sauter, d√©cr√©menter le compteur
            if (nextPlayer.skipNextTurns && nextPlayer.skipNextTurns > 0) {
              const playerIndex = updatedPlayers.findIndex(p => p.id === nextPlayer.id);
              if (playerIndex !== -1) {
                updatedPlayers[playerIndex] = {
                  ...nextPlayer,
                  skipNextTurns: nextPlayer.skipNextTurns - 1,
                };
              }
            }
            
            // Passer au joueur suivant
            nextPlayerIndex = (nextPlayerIndex + 1) % updatedPlayers.length;
            attempts++;
          }
          // Incr√©menter currentTurn car on passe au joueur suivant
          shouldIncrementTurn = true;
        }
      }

      const winnerId = alivePlayers.length === 1 ? alivePlayers[0].id : undefined;

      // Pr√©parer les mises √† jour
      const newCurrentTurn = winnerId ? game.currentTurn : (shouldIncrementTurn ? game.currentTurn + 1 : game.currentTurn);
      const gameUpdates: any = {
        players: updatedPlayers,
        currentPlayerIndex: winnerId ? game.currentPlayerIndex : nextPlayerIndex,
        currentTurn: newCurrentTurn,
        phase: winnerId ? 'finished' : 'playing',
        status: winnerId ? 'finished' : 'active',
      };

      // Ajouter winnerId seulement s'il y a un gagnant
      if (winnerId) {
        gameUpdates.winnerId = winnerId;
      } else {
        // R√©initialiser le timer pour le nouveau tour seulement si la partie continue
        gameUpdates.turnStartTime = Date.now();
      }

      // Mettre √† jour la partie
      await updateGame(game.id, gameUpdates);
      
      // Si le joueur a encore des tours bonus apr√®s ce tir, r√©initialiser hasShotThisTurn pour qu'il puisse rejouer
      // Sinon, marquer qu'on a tir√© ce tour
      if (hasRemainingBonusTurns) {
        // Il reste encore des tours bonus, r√©initialiser pour le prochain tour bonus
        setHasShotThisTurn(false);
      } else {
        // Dernier tour bonus ou pas de tours bonus, marquer comme termin√©
        setHasShotThisTurn(true);
      }
      
      setSelectedTarget(null);
      
      // Activer les bombes apr√®s le changement de tour
      if (!winnerId) {
        await activateBombs(game.id);
      }
      
      setError('');
    } catch (error: any) {
      console.error('Erreur lors du tir:', error);
      setError(error.message || 'Erreur lors du tir');
    }
  };

  // G√©rer le placement d'une bombe
  const handleBombPlace = async (opponentId: string, x: number, y: number) => {
    if (!game || !user || !isCurrentTurn || !currentPlayer) return;
    if (game.phase !== 'playing') return;
    if (currentPlayer.bombsRemaining <= 0) {
      setError('Vous n\'avez plus de bombes disponibles');
      return;
    }

    try {
      await placeBomb(game.id, user.uid, opponentId, { x, y });
      
      // Passer au joueur suivant apr√®s placement (placer une bombe termine le tour)
      const nextPlayerIndex = (game.currentPlayerIndex + 1) % game.players.length;
      await updateGame(game.id, {
        currentPlayerIndex: nextPlayerIndex,
        currentTurn: game.currentTurn + 1, // Incr√©menter le tour car placer une bombe est une action qui termine le tour
        turnStartTime: Date.now(), // R√©initialiser le timer pour le nouveau tour
      });
      
      // Activer les bombes
      await activateBombs(game.id);
      
      // Revenir en mode tir
      setActionMode('shot');
    } catch (error: any) {
      console.error('Erreur lors du placement de la bombe:', error);
      setError(error.message || 'Erreur lors du placement de la bombe');
    }
  };

  // G√©rer le d√©samor√ßage d'une bombe
  const handleDefuseBomb = async (bombId: string) => {
    if (!game || !user || !isCurrentTurn || !currentPlayer) return;
    if (game.phase !== 'playing') return;
    if (hasShotThisTurn) {
      setError('Vous avez d√©j√† utilis√© votre action ce tour.');
      return;
    }

    try {
      // Trouver la bombe et son propri√©taire avant le d√©samor√ßage
      let bombOwnerId: string | null = null;
      for (const player of game.players) {
        const bomb = player.bombsPlaced.find(b => b.id === bombId && b.targetPlayerId === user.uid);
        if (bomb && !bomb.detonated && !bomb.defused) {
          bombOwnerId = player.id;
          break;
        }
      }
      
      if (!bombOwnerId) {
        setError('Bombe non trouv√©e');
        return;
      }
      
      await defuseBomb(game.id, user.uid, bombId);
      
      // Recharger le jeu pour avoir les derni√®res donn√©es (avec skipNextTurns)
      const updatedGame = await getGame(game.id);
      if (!updatedGame) return;
      
      // Le joueur qui a plac√© la bombe doit recevoir le tour pour jouer deux fois
      const bombOwnerIndex = updatedGame.players.findIndex(p => p.id === bombOwnerId);
      if (bombOwnerIndex === -1) {
        setError('Joueur propri√©taire de la bombe non trouv√©');
        return;
      }
      
      // V√©rifier que le propri√©taire de la bombe est vivant
      const bombOwner = updatedGame.players[bombOwnerIndex];
      if (!bombOwner.isAlive) {
        // Si le propri√©taire est mort, trouver le prochain joueur qui peut jouer
        // (en tenant compte des skipNextTurns du joueur qui a d√©samorc√©)
        let nextPlayerIndex = (updatedGame.currentPlayerIndex + 1) % updatedGame.players.length;
        let attempts = 0;
        const maxAttempts = updatedGame.players.length * 2;
        const updatedPlayers = [...updatedGame.players];
        
        while (attempts < maxAttempts) {
          const nextPlayer = updatedPlayers[nextPlayerIndex];
          
          if (nextPlayer.isAlive && (!nextPlayer.skipNextTurns || nextPlayer.skipNextTurns === 0)) {
            break;
          }
          
          // Si le joueur a des tours √† sauter, d√©cr√©menter le compteur
          if (nextPlayer.skipNextTurns && nextPlayer.skipNextTurns > 0) {
            const playerIndex = updatedPlayers.findIndex(p => p.id === nextPlayer.id);
            if (playerIndex !== -1) {
              updatedPlayers[playerIndex] = {
                ...nextPlayer,
                skipNextTurns: nextPlayer.skipNextTurns - 1,
              };
            }
          }
          
          nextPlayerIndex = (nextPlayerIndex + 1) % updatedPlayers.length;
          attempts++;
        }
        
        await updateGame(game.id, {
          players: updatedPlayers,
          currentPlayerIndex: nextPlayerIndex,
          currentTurn: (updatedGame.currentTurn || 0) + 1,
          turnStartTime: Date.now(),
        });
      } else {
        // Donner le tour au propri√©taire de la bombe pour qu'il puisse jouer deux fois
        // Le joueur qui a d√©samorc√© a skipNextTurns: 2, donc il sautera automatiquement
        // les 2 prochains tours o√π c'est son tour (g√©r√© par subscribeToGame)
        await updateGame(game.id, {
          currentPlayerIndex: bombOwnerIndex,
          currentTurn: (updatedGame.currentTurn || 0) + 1,
          turnStartTime: Date.now(), // R√©initialiser le timer pour le nouveau tour
        });
      }
      
      // Activer les bombes
      await activateBombs(game.id);
      
      // Marquer qu'on a utilis√© son action ce tour
      setHasShotThisTurn(true);
    } catch (error: any) {
      console.error('Erreur lors du d√©samor√ßage:', error);
      setError(error.message || 'Erreur lors du d√©samor√ßage');
    }
  };

  // G√©rer l'abandon de la partie
  const handleSurrender = async () => {
    if (!game || !user || !currentPlayer) return;
    if (game.phase !== 'playing') return;

    // Demander confirmation
    if (!confirm('√ätes-vous s√ªr de vouloir abandonner la partie ?')) {
      return;
    }

    try {
      // Marquer le joueur comme mort
      const updatedPlayers = game.players.map(p => {
        if (p.id === user.uid) {
          return {
            ...p,
            isAlive: false,
          };
        }
        return p;
      });

      // V√©rifier s'il reste un seul joueur vivant
      const alivePlayers = updatedPlayers.filter(p => p.isAlive);
      const winnerId = alivePlayers.length === 1 ? alivePlayers[0].id : undefined;

      // Mettre √† jour la partie
      const gameUpdates: any = {
        players: updatedPlayers,
        phase: winnerId ? 'finished' : 'playing',
        status: winnerId ? 'finished' : 'active',
      };

      if (winnerId) {
        gameUpdates.winnerId = winnerId;
      }

      await updateGame(game.id, gameUpdates);
    } catch (error: any) {
      console.error('Erreur lors de l\'abandon:', error);
      setError('Erreur lors de l\'abandon');
    }
  };

  // G√©rer le choix apr√®s la fin de partie
  const handleEndGameChoice = async (choice: 'lobby' | 'menu') => {
    if (!game || !user) return;

    try {
      setPlayerChoiceState(choice);
      // Enregistrer le choix d'abord
      await setPlayerChoice(game.id, user.uid, choice);
      
      // Recharger le jeu pour avoir les choix √† jour
      const updatedGame = await getGame(game.id);
      if (!updatedGame) return;
      
      const choices = updatedGame.playerChoices || {};
      
      // Si choix "lobby", retourner imm√©diatement au lobby sans attendre les autres
      if (choice === 'lobby') {
        // V√©rifier qu'au moins un joueur a choisi lobby (le choix vient d'√™tre enregistr√©)
        const playersWhoChoseLobby = updatedGame.players.filter(p => choices[p.id] === 'lobby');
        if (playersWhoChoseLobby.length > 0) {
          await handleGameEnd(game.id, true); // true = retour imm√©diat
          // La redirection sera g√©r√©e par le subscribeToGame qui d√©tecte le changement de phase
        }
        return;
      }
      
      // Si choix "menu", quitter imm√©diatement vers le dashboard
      if (choice === 'menu') {
        // V√©rifier si tous les joueurs ont choisi menu (suppression du lobby)
        const allChoseMenu = updatedGame.players.every(p => choices[p.id] === 'menu');
        
        if (allChoseMenu) {
          // Tous ont choisi menu, supprimer le lobby
          await handleGameEnd(game.id);
        }
        
        // Quitter vers le dashboard
        router.push('/dashboard');
        return;
      }
    } catch (error: any) {
      console.error('Erreur lors du choix:', error);
      setError(error.message || 'Erreur lors de l\'enregistrement du choix');
    }
  };

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-xl">Chargement de la partie...</div>
      </div>
    );
  }

  if (!game || !currentPlayer) {
    return null; // Redirection en cours
  }

  // Si la phase est 'lobby', ne pas afficher l'interface de jeu (redirection en cours)
  const gamePhase = game.phase;
  if (gamePhase === 'lobby') {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-xl">Redirection vers le lobby...</div>
      </div>
    );
  }

  // Obtenir le gagnant si la partie est termin√©e
  const winner = game.winnerId ? game.players.find(p => p.id === game.winnerId) : null;
  const isWinner = winner?.id === user?.uid;
  const choices = game.playerChoices || {};
  const hasChosen = user ? choices[user.uid] !== undefined : false;
  
  // Obtenir les choix de tous les autres joueurs
  const otherPlayersChoices = game.players
    .filter(p => p.id !== user?.uid)
    .map(p => ({
      player: p,
      choice: choices[p.id],
    }));
  
  // V√©rifier si le jeu est retourn√© au lobby
  const isBackToLobby = game.phase === 'lobby';

  // Cr√©er une grille masqu√©e pour l'adversaire (ne montre pas les navires, seulement les tirs)
  const getOpponentGrid = (opponent: Player): CellState[][] => {
    return opponent.board.cells.map((row, y) =>
      row.map((cell, x) => {
        // Si c'est un navire non touch√©, on le masque (affiche comme 'empty')
        if (cell === 'ship') {
          return 'empty';
        }
        // Si c'est revealed_ship ou revealed_empty, on les garde tels quels
        // Sinon, on affiche l'√©tat r√©el (hit, miss, revealed)
        return cell;
      })
    );
  };

  return (
    <div className="min-h-screen bg-gray-100 py-8">
      {/* Modal de fin de partie */}
      {game.phase === 'finished' && winner && (
        <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 p-4">
          <div className="bg-gradient-to-br from-white via-yellow-50 to-orange-50 rounded-2xl shadow-2xl p-8 max-w-md w-full border-4 border-yellow-400 animate-scale-in">
            <div className="text-center">
              <div className="text-7xl mb-4 animate-bounce">
                {isWinner ? 'üèÜ' : 'üíÄ'}
              </div>
              <h2 className="text-4xl font-bold mb-3 bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
                {isWinner ? 'Victoire !' : 'D√©faite'}
              </h2>
              <p className="text-xl text-gray-700 mb-2">
                Le joueur
              </p>
              <p className="text-2xl font-bold mb-6" style={{ color: winner.color }}>
                {winner.name}
              </p>
              <p className="text-xl text-gray-700 mb-8">
                a gagn√© !
              </p>

              {!hasChosen ? (
                <div className="space-y-4">
                  <button
                    onClick={() => handleEndGameChoice('lobby')}
                    className="w-full bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white font-bold py-4 px-6 rounded-xl shadow-lg transition-all hover:scale-105 active:scale-95 text-lg"
                  >
                    üè† Retour au Lobby
                  </button>
                  <button
                    onClick={() => handleEndGameChoice('menu')}
                    className="w-full bg-gradient-to-r from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-700 text-white font-bold py-4 px-6 rounded-xl shadow-lg transition-all hover:scale-105 active:scale-95 text-lg"
                  >
                    üè° Retour au Menu
                  </button>
                </div>
              ) : (
                <div className="space-y-4">
                  <div className="p-4 bg-blue-50 rounded-lg border-2 border-blue-200">
                    <p className="text-gray-700 font-semibold">
                      Vous avez choisi : <span className="text-blue-600 font-bold">{playerChoice === 'lobby' ? 'üè† Lobby' : 'üè° Menu'}</span>
                    </p>
                    {playerChoice === 'lobby' && (
                      <p className="text-sm text-gray-600 mt-2">
                        Vous √™tes retourn√© au lobby. L'autre joueur peut vous y rejoindre.
                      </p>
                    )}
                    {playerChoice === 'menu' && (
                      <p className="text-sm text-gray-600 mt-2">
                        Vous avez quitt√© la partie.
                      </p>
                    )}
                  </div>
                  
                  {/* Afficher l'√©tat des autres joueurs */}
                  {otherPlayersChoices.length > 0 && (
                    <div className="space-y-2">
                      {otherPlayersChoices.map(({ player, choice }) => (
                        <div
                          key={player.id}
                          className={`p-4 rounded-lg border-2 ${
                            choice === 'lobby'
                              ? 'bg-green-50 border-green-200'
                              : choice === 'menu'
                              ? 'bg-red-50 border-red-200'
                              : 'bg-yellow-50 border-yellow-200'
                          }`}
                        >
                          <p className="text-gray-700 font-semibold flex items-center">
                            <span className="font-bold mr-2" style={{ color: player.color }}>
                              {player.name}
                            </span>
                            {choice === 'lobby' && (
                              <>
                                <span className="text-green-600 font-bold">üè† Retourn√© au lobby</span>
                                {playerChoice === 'lobby' && (
                                  <span className="ml-2 text-sm text-green-600">(Vous pouvez le rejoindre)</span>
                                )}
                              </>
                            )}
                            {choice === 'menu' && (
                              <span className="text-red-600 font-bold">üè° A quitt√© la partie</span>
                            )}
                            {!choice && (
                              <>
                                <span className="animate-spin mr-2">‚è≥</span>
                                <span className="text-yellow-600">En attente de son choix...</span>
                              </>
                            )}
                          </p>
                        </div>
                      ))}
                    </div>
                  )}
                  
                  {/* Si le joueur a choisi menu mais que l'autre est au lobby, proposer de le rejoindre */}
                  {playerChoice === 'menu' && otherPlayersChoices.some(({ choice }) => choice === 'lobby') && (
                    <button
                      onClick={() => {
                        setPlayerChoiceState('lobby');
                        handleEndGameChoice('lobby');
                      }}
                      className="w-full bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white font-bold py-3 px-6 rounded-xl shadow-lg transition-all hover:scale-105 active:scale-95"
                    >
                      üè† Rejoindre le lobby
                    </button>
                  )}
                </div>
              )}
            </div>
          </div>
        </div>
      )}

      <div className="max-w-7xl mx-auto px-2 sm:px-4 lg:px-8">
        {/* Header */}
        <div className="mb-6">
          <h1 className="text-2xl sm:text-3xl lg:text-4xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent mb-3 sm:mb-4 text-center sm:text-left">
            ‚öîÔ∏è Partie en cours
          </h1>
          <div className="flex flex-wrap items-center justify-center sm:justify-start gap-2 sm:gap-4">
            <div className={`px-3 sm:px-5 py-2 sm:py-3 rounded-xl font-bold text-sm sm:text-base shadow-lg transition-all ${
              isCurrentTurn 
                ? 'bg-gradient-to-r from-green-500 to-emerald-600 text-white animate-pulse' 
                : currentPlayerTurn?.id === user?.uid && currentPlayerTurn?.skipNextTurns && currentPlayerTurn.skipNextTurns > 0
                ? 'bg-gradient-to-r from-orange-500 to-orange-600 text-white'
                : 'bg-gradient-to-r from-gray-200 to-gray-300 text-gray-700'
            }`}>
              {isCurrentTurn ? (
                currentPlayer?.bonusTurns && currentPlayer.bonusTurns > 0
                  ? `üéØ C'est votre tour ! (${currentPlayer.bonusTurns} tour${currentPlayer.bonusTurns > 1 ? 's' : ''} bonus restant${currentPlayer.bonusTurns > 1 ? 's' : ''})`
                  : 'üéØ C\'est votre tour !'
              ) : currentPlayerTurn?.id === user?.uid && currentPlayerTurn?.skipNextTurns && currentPlayerTurn.skipNextTurns > 0 ? (
                `‚è∏Ô∏è Vous sautez ${currentPlayerTurn.skipNextTurns} tour${currentPlayerTurn.skipNextTurns > 1 ? 's' : ''} (d√©samor√ßage)`
              ) : (
                `‚è≥ Tour de ${currentPlayerTurn?.name || '...'}`
              )}
            </div>
            <div className="px-3 sm:px-4 py-2 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg border border-blue-200 text-gray-700 font-semibold text-sm sm:text-base">
              üë• Joueurs vivants: <span className="text-blue-600">{game.players.filter(p => p.isAlive).length}/{game.players.length}</span>
            </div>
            
            {/* Timer du tour */}
            {timeRemaining !== null && game.settings.turnTimeLimit > 0 && (
              <div className={`px-3 sm:px-4 py-2 rounded-lg font-bold text-sm sm:text-base shadow-lg transition-all ${
                timeRemaining <= 10
                  ? 'bg-gradient-to-r from-red-500 to-red-600 text-white animate-pulse'
                  : timeRemaining <= 20
                  ? 'bg-gradient-to-r from-orange-500 to-orange-600 text-white'
                  : 'bg-gradient-to-r from-blue-500 to-blue-600 text-white'
              }`}>
                ‚è±Ô∏è {timeRemaining}s
              </div>
            )}
            
            {/* Bouton Abandonner */}
            {game.phase === 'playing' && currentPlayer && currentPlayer.isAlive && (
              <button
                onClick={handleSurrender}
                className="px-4 py-2 bg-gradient-to-r from-red-500 to-red-600 hover:from-red-600 hover:to-red-700 text-white font-bold rounded-xl shadow-lg transition-all hover:scale-105 active:scale-95 flex items-center gap-2"
                title="Abandonner la partie"
              >
                üè≥Ô∏è Abandonner
              </button>
            )}
            
            {/* Boutons Tir/Bombe */}
            {isCurrentTurn && !hasShotThisTurn && (
              <div className="flex flex-wrap items-center gap-3 justify-center sm:justify-start">
                {game.settings.enableBombs && game.settings.bombsPerPlayer > 0 && (
                  <>
                    <button
                      onClick={() => {
                        setActionMode('shot');
                        setSelectedTarget(null);
                        setError('');
                      }}
                      className={`px-4 sm:px-5 py-2 sm:py-3 rounded-xl font-bold text-sm sm:text-base transition-all shadow-lg ${
                        actionMode === 'shot'
                          ? 'bg-gradient-to-r from-blue-500 to-blue-600 text-white scale-105 ring-4 ring-blue-300'
                          : 'bg-gradient-to-r from-gray-200 to-gray-300 text-gray-700 hover:from-gray-300 hover:to-gray-400 hover:scale-105'
                      }`}
                    >
                      üéØ Tir
                    </button>
                    <button
                      onClick={() => {
                        setActionMode('bomb');
                        setSelectedTarget(null);
                        setError('');
                      }}
                      disabled={currentPlayer.bombsRemaining <= 0}
                      className={`px-4 sm:px-5 py-2 sm:py-3 rounded-xl font-bold text-sm sm:text-base transition-all shadow-lg ${
                        actionMode === 'bomb'
                          ? 'bg-gradient-to-r from-orange-500 to-orange-600 text-white scale-105 ring-4 ring-orange-300'
                          : currentPlayer.bombsRemaining > 0
                          ? 'bg-gradient-to-r from-gray-200 to-gray-300 text-gray-700 hover:from-gray-300 hover:to-gray-400 hover:scale-105'
                          : 'bg-gradient-to-r from-gray-100 to-gray-200 text-gray-400 cursor-not-allowed'
                      }`}
                    >
                      üí£ Bombe <span className="ml-1 bg-white/30 px-2 py-0.5 rounded-full">({currentPlayer.bombsRemaining})</span>
                    </button>
                  </>
                )}
                {hasShotThisTurn && (
                  <div className="px-4 py-2 bg-yellow-100 border-2 border-yellow-400 text-yellow-800 rounded-lg font-semibold">
                    ‚úì Tir effectu√© ce tour
                  </div>
                )}
              </div>
            )}
          </div>
        </div>

        {/* L√©gende des couleurs */}
        <div className="mb-4 sm:mb-6 bg-gradient-to-br from-white to-gray-50 rounded-xl shadow-lg border-2 border-gray-200 p-3 sm:p-5">
          <h3 className="text-lg sm:text-xl font-bold text-gray-900 mb-3 sm:mb-4 text-center sm:text-left">üé® L√©gende</h3>
          <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2 sm:gap-4">
            <div className="flex items-center space-x-2">
              <div className="w-6 h-6 bg-red-600 border-2 border-red-700 rounded shadow-inner"></div>
              <span className="text-sm text-gray-700 font-medium">Touch√©</span>
            </div>
            <div className="flex items-center space-x-2">
              <div className="w-6 h-6 bg-sky-300 border-2 border-sky-400 rounded"></div>
              <span className="text-sm text-gray-700 font-medium">Rat√©</span>
            </div>
            <div className="flex items-center space-x-2">
              <div className="w-6 h-6 bg-blue-100 border-2 border-blue-200 rounded"></div>
              <span className="text-sm text-gray-700 font-medium">Eau</span>
            </div>
            <div className="flex items-center space-x-2">
              <div className="w-6 h-6 bg-amber-400 border-2 border-amber-500 rounded shadow-md"></div>
              <span className="text-sm text-gray-700 font-medium">R√©v√©l√© (navire)</span>
            </div>
            <div className="flex items-center space-x-2">
              <div className="w-6 h-6 bg-cyan-200 border-2 border-cyan-300 rounded"></div>
              <span className="text-sm text-gray-700 font-medium">R√©v√©l√© (vide)</span>
            </div>
            {game.settings.enableBombs && game.settings.bombsPerPlayer > 0 && (
              <div className="flex items-center space-x-2">
                <div className="w-6 h-6 bg-orange-500 border-2 border-orange-600 rounded-full flex items-center justify-center text-white text-xs font-bold shadow-lg">
                  üí£
                </div>
                <span className="text-sm text-gray-700 font-medium">Bombe active</span>
              </div>
            )}
          </div>
        </div>

        {error && (
          <div className="mb-4 p-4 bg-gradient-to-r from-red-50 to-pink-50 border-2 border-red-300 text-red-700 rounded-xl shadow-lg">
            <div className="flex items-center">
              <span className="text-xl mr-2">‚ö†Ô∏è</span>
              <span className="font-semibold">{error}</span>
            </div>
          </div>
        )}

        {/* S√©lecteur d'adversaire (si c'est votre tour et mode tir) */}
        {isCurrentTurn && actionMode === 'shot' && !hasShotThisTurn && opponents.length > 1 && (
          <div className="mb-4 p-4 bg-gradient-to-br from-blue-50 to-indigo-50 rounded-xl shadow-lg border-2 border-blue-200">
            <h3 className="text-lg font-bold text-blue-900 mb-3 text-center sm:text-left">
              üéØ S√©lectionnez un adversaire √† attaquer
            </h3>
            <div className="flex flex-wrap gap-3 justify-center sm:justify-start">
              {opponents.map((opponent) => (
                <button
                  key={opponent.id}
                  onClick={() => {
                    setSelectedTarget(opponent.id);
                    setError('');
                  }}
                  className={`px-4 py-2 rounded-lg font-semibold transition-all shadow-md ${
                    selectedTarget === opponent.id
                      ? 'bg-gradient-to-r from-red-500 to-red-600 text-white scale-105 ring-4 ring-red-300'
                      : 'bg-white text-gray-700 hover:bg-gray-100 border-2 border-gray-300'
                  }`}
                  style={selectedTarget !== opponent.id ? { borderColor: opponent.color } : {}}
                >
                  <span className="w-3 h-3 rounded-full inline-block mr-2" style={{ backgroundColor: opponent.color }}></span>
                  {opponent.name}
                </button>
              ))}
            </div>
            {selectedTarget && (
              <p className="mt-3 text-sm text-blue-700 text-center sm:text-left">
                ‚úì Adversaire s√©lectionn√© : <span className="font-bold">{opponents.find(o => o.id === selectedTarget)?.name}</span>
              </p>
            )}
          </div>
        )}

        {/* Grilles des adversaires */}
        <div className={`grid gap-4 sm:gap-6 mb-6 ${
          opponents.length === 1 
            ? 'grid-cols-1' 
            : opponents.length === 2 
            ? 'grid-cols-1 lg:grid-cols-2' 
            : 'grid-cols-1 lg:grid-cols-2 xl:grid-cols-3'
        }`}>
          {opponents.map((opponent) => (
            <div key={opponent.id} className="bg-gradient-to-br from-white to-gray-50 rounded-xl shadow-xl border-2 border-gray-200 p-3 sm:p-6">
              <h2 className="text-lg sm:text-2xl font-bold mb-3 sm:mb-4 flex items-center justify-center sm:justify-start" style={{ color: opponent.color }}>
                <span className="w-3 h-3 sm:w-4 sm:h-4 rounded-full mr-2" style={{ backgroundColor: opponent.color }}></span>
                {opponent.name}
                {!opponent.isAlive && <span className="ml-2 text-red-500 text-lg sm:text-xl">üíÄ</span>}
              </h2>
              
              <div className="flex justify-center relative overflow-x-auto">
                <div className="inline-block relative">
                  <Grid
                    cells={getOpponentGrid(opponent)}
                    onCellClick={
                      isCurrentTurn && opponent.isAlive && !hasShotThisTurn
                        ? actionMode === 'shot'
                          ? (opponents.length === 1 || selectedTarget === opponent.id)
                            ? (x, y) => handleCellClick(opponent.id, x, y)
                            : undefined
                          : (x, y) => handleBombPlace(opponent.id, x, y)
                        : undefined
                    }
                    interactive={!!(isCurrentTurn && opponent.isAlive && !hasShotThisTurn && (actionMode === 'bomb' || opponents.length === 1 || selectedTarget === opponent.id))}
                    showCoordinates={true}
                    className={`shadow-md ${(opponents.length === 1 || selectedTarget === opponent.id) && isCurrentTurn && actionMode === 'shot' ? 'ring-4 ring-red-400 ring-opacity-50' : ''}`}
                  />
                  
                  {/* Afficher les bombes actives sur cette grille */}
                  {game.players
                    .flatMap(p => p.bombsPlaced.filter(b => b.targetPlayerId === opponent.id && !b.detonated && !b.defused))
                    .map(bomb => {
                      const turnsRemaining = Math.max(0, bomb.activatesAtTurn - (game.currentTurn || 0));
                      // Calcul du positionnement relatif √† la grille en pourcentage
                      const gridSize = 12; // BOARD_SIZE
                      const cellWidthPercent = 100 / (gridSize + 1); // +1 pour la colonne de coordonn√©es
                      const cellHeightPercent = 100 / (gridSize + 1); // +1 pour la ligne de coordonn√©es
                      
                      // Position en pourcentage : coordonn√©es (1 cellule) + position de la bombe
                      const leftPercent = cellWidthPercent + (bomb.position.x * cellWidthPercent) + (cellWidthPercent / 2);
                      const topPercent = cellHeightPercent + (bomb.position.y * cellHeightPercent) + (cellHeightPercent / 2);
                      
                      return (
                        <div
                          key={bomb.id}
                          className="absolute bg-gradient-to-br from-orange-500 to-orange-600 text-white text-xs font-bold rounded-full w-8 h-8 sm:w-10 sm:h-10 flex items-center justify-center border-2 sm:border-4 border-white shadow-xl z-10 animate-pulse pointer-events-none"
                          style={{
                            left: `${leftPercent}%`,
                            top: `${topPercent}%`,
                            transform: 'translate(-50%, -50%)',
                          }}
                          title={`üí£ Bombe - Activation dans ${turnsRemaining} tour${turnsRemaining > 1 ? 's' : ''}`}
                        >
                          <span className="text-sm sm:text-lg">üí£</span>
                          <span className="absolute -bottom-1 -right-1 bg-red-600 text-white text-[8px] sm:text-[10px] font-bold rounded-full w-4 h-4 sm:w-5 sm:h-5 flex items-center justify-center border-2 border-white">
                            {turnsRemaining}
                          </span>
                        </div>
                      );
                    })}
                </div>
              </div>

              {/* Statistiques */}
              <div className="mt-4 p-4 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg border border-blue-200">
                <div className="text-sm font-semibold text-gray-700">
                  ‚öì Navires coul√©s: <span className="text-blue-600">{opponent.board.ships.filter(s => s.sunk).length}/{opponent.board.ships.length}</span>
                </div>
              </div>
            </div>
          ))}
        </div>

        {/* Votre grille (pour r√©f√©rence) */}
        <div className="mt-4 sm:mt-8 bg-gradient-to-br from-white to-gray-50 rounded-xl shadow-xl border-2 border-gray-200 p-3 sm:p-6">
          <h2 className="text-lg sm:text-2xl font-bold mb-3 sm:mb-4 text-gray-800 text-center sm:text-left">‚öì Votre grille</h2>
          <div className="flex justify-center relative overflow-x-auto">
            <div className="inline-block relative">
              <Grid
                cells={currentPlayer.board.cells}
                showCoordinates={true}
                className="shadow-md"
              />
              
              {/* Afficher les bombes actives sur votre grille avec bouton de d√©samor√ßage */}
              {game.players
                .flatMap(p => p.bombsPlaced.filter(b => b.targetPlayerId === user?.uid && !b.detonated && !b.defused))
                .map(bomb => {
                  const turnsRemaining = Math.max(0, bomb.activatesAtTurn - (game.currentTurn || 0));
                  const bombOwner = game.players.find(p => p.id === bomb.ownerId);
                  // Calcul du positionnement relatif √† la grille
                  // Utiliser un pourcentage pour s'adapter √† la taille r√©elle de la grille
                  const gridSize = 12; // BOARD_SIZE
                  const cellWidthPercent = 100 / (gridSize + 1); // +1 pour la colonne de coordonn√©es
                  const cellHeightPercent = 100 / (gridSize + 1); // +1 pour la ligne de coordonn√©es
                  
                  // Position en pourcentage : coordonn√©es (1 cellule) + position de la bombe
                  const leftPercent = cellWidthPercent + (bomb.position.x * cellWidthPercent) + (cellWidthPercent / 2);
                  const topPercent = cellHeightPercent + (bomb.position.y * cellHeightPercent) + (cellHeightPercent / 2);
                  
                  return (
                    <div
                      key={bomb.id}
                      className="absolute z-10 flex flex-col items-center pointer-events-none"
                      style={{
                        left: `${leftPercent}%`,
                        top: `${topPercent}%`,
                        transform: 'translate(-50%, -50%)',
                      }}
                    >
                      <div className="bg-gradient-to-br from-orange-500 to-orange-600 text-white text-xs font-bold rounded-full w-8 h-8 sm:w-10 sm:h-10 flex items-center justify-center border-2 sm:border-4 border-white shadow-xl mb-2 animate-pulse pointer-events-auto">
                        <span className="text-sm sm:text-lg">üí£</span>
                        <span className="absolute -bottom-1 -right-1 bg-red-600 text-white text-[8px] sm:text-[10px] font-bold rounded-full w-4 h-4 sm:w-5 sm:h-5 flex items-center justify-center border-2 border-white">
                          {turnsRemaining}
                        </span>
                      </div>
                      {isCurrentTurn && (
                        <button
                          onClick={() => handleDefuseBomb(bomb.id)}
                          className="bg-gradient-to-r from-red-500 to-red-600 hover:from-red-600 hover:to-red-700 text-white text-[10px] sm:text-xs font-bold px-2 sm:px-3 py-1 sm:py-1.5 rounded-lg shadow-lg whitespace-nowrap transition-all hover:scale-105 active:scale-95 pointer-events-auto"
                          title={`D√©samorcer la bombe de ${bombOwner?.name || 'l\'adversaire'}`}
                        >
                          ‚úÇÔ∏è D√©samorcer
                        </button>
                      )}
                    </div>
                  );
                })}
            </div>
          </div>
        </div>

        {/* Chat en jeu */}
        <div className="mt-6">
          <GameChat
            messages={chatMessages}
            onSendMessage={handleSendChatMessage}
            currentUserId={user?.uid}
            canChat={!!currentPlayer}
            title="Chat en jeu"
            gamePhase={game.phase}
            filterByPhase={true}
          />
        </div>
      </div>
    </div>
  );
}
